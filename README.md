# shol

最高に面白い独自パラダイム言語 Shol のコンパイラを制作中です。

## 主な概念

- **リソース**：数値や文字列といった個々のデータを指します。
- **ノード**：リソースが集まる場所の単位です。
- **フラグ**：プロデューサやトランスフォーマの発火に関わる条件です。
- **トランスフォーマ**：リソースを新たなリソースに変換します。

## コード例

### Hello, world!
```
#[stdout]
Hello, world!
```
組み込みノードの `stdout` を拡張し、初期リソースに文字列をセットします。

### FizzBuzz
```
[nGen]
(1, 101)
. $[0] < $[1] => ($[0]+1, $[1]) #fizzBuzz => $[0]

[fizzBuzz]
. $%3 eq 0 => Fizz
. $%5 eq 0 => Buzz
. $1 eq Fizz, $2 eq Buzz => FizzBuzz
. 1 #stdout => $, \n
```

`nGen` ノードは 1〜100 の整数リソースを `fizzBuzz` ノードに転送します。

`fizzBuzz` ノードは整数リソースを FizzBuzz に変換して標準出力に送ります。

コード中に現れるものが、それぞれどの概念に対応するかを以下に示します。
```
[nGen]          // ノード定義
(1, 101)        // リソース
. $[0] < $[1]       // フラグ
=> ($[0]+1, $[1])   // トランスフォーマ
#fizzBuzz => $[0]   // トランスフォーマ

[fizzBuzz]      // ノード定義
. $%3 eq 0      // フラグ
=> Fizz         // トランスフォーマ
. $%5 eq 0      // フラグ
=> Buzz         // トランスフォーマ
. $1 eq Fizz, $2 eq Buzz    // フラグ
=> FizzBuzz     // トランスフォーマ
. 1             // フラグ
#stdout => $, \n    // トランスフォーマ
```


### 関数の実装
```

// (#,a,b) -> a+b
[add]
. 1 #$[0] => $[1]+$[2]

// (#,n) -> n!
[factorial]
. $ len eq 2 => ($[0], $[1], 1)
. $[1]<=1 #$[0] => $[2]
. !_ => ($[0], $[1]-1, $[2]*$[1])

[send]
a
. $ is int #factorial => (#printResult, $)
. !_ #add => (#, 2, 3)

[printResult]
. 1 #stdout => "(2+3)! = ", $, \n

```

ノードの参照(`#`は自分自身を表す)をリソースとして渡すことができ、これを利用して関数を実装することができます。

`. !_` は直前のフラグ(`_`)を活性化しない(`!`)リソースに活性化するフラグを表しています。以下のように書き換え可能です。

```
[factorial]
.end $[1]<=1 #$[0] => $[2]
. $ len eq 2 => ($[0], $[1], 1)
. 1 - end => ($[0], $[1]-1, $[2]*$[1])
```

全体集合 `1` から、フラグ `end` を活性化するリソースの集合を除いた差集合が、3 つ目のフラグを活性化させます。
