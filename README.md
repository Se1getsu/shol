# shol

最高に面白い独自パラダイム言語 Shol のコンパイラを制作中です。

## 用語と概念

- **コロニー**：クロックごとに規則が適用されるリソースの集合
- **リソース**：数値や文字列といった個々のデータ
- **規則**：コロニーに変化を与える変換規則
- **クロック**：規則が適用される周期

これらをオブジェクト指向の概念と対比してみましょう。

オブジェクト指向: *オブジェクト* は *属性* とそれを操作する *メソッド* を持ちます。オブジェクトは外部からの *メソッド呼び出し* によって**受動的に**属性を変化させます。

Shol: *コロニー* は *リソース集合* とそれを変化させる *規則* を持ちます。コロニーは *クロック* によって**能動的に**リソース集合を変化させます。

このような性質から、Shol には Java の main 関数のようなエントリーポイントは存在しません。

規則は以下の要素から構成されます。

- **フラグ**：規則が実行されるリソースの条件
- **プロデューサ**：新たなリソースを生成する規則
- **トランスフォーマ**：新たなリソースに変換する規則

フラグの条件を満たすリソースのことを、そのフラグを**活性化する**リソースと言います。トランスフォーマではフラグを活性化したリソースはコロニーから消去されます。

規則はコード上で上に書かれたものほど優先されます。1 クロックの間に、優先順位の高い規則から順に実行され、各コロニーのリソース集合を変化させます。

- **同率優先規則**：直前の規則と同時に実行される規則

## コード例

### Hello, world!

```
#[stdout]
Hello, world!
```

組み込みのコロニーである `stdout` を拡張し、出力する文字列を初期リソースに配置すると、出力が行われます。

### FizzBuzz

```
[nGen]
1
. $<100 = $+1
| 1 #fizzBuzz => $

[fizzBuzz]
. $%3 eq 0 => Fizz
| $%5 eq 0 => Buzz
. Fizz, Buzz => FizzBuzz
. 1 #stdout => $, \n
```

`nGen` コロニーは 1〜100 の整数リソースを `fizzBuzz` コロニーに転送します。`=` や `=>` の直前に `#` とコロニー名を添えると、別のコロニーにリソースを出力できます。

`fizzBuzz` コロニーは整数リソースを FizzBuzz に変換して標準出力に送ります。

コード中に現れるものが、それぞれどの概念に対応するかを以下に示します。

```
[nGen]  // コロニー定義
1       // リソース
. $<100 = $+1       // 規則(プロデューサ)
| 1 #fizzBuzz => $  // 同率優先規則(トランスフォーマ)

[fizzBuzz]          // コロニー定義
. $%3 eq 0 => Fizz  // 規則(トランスフォーマ)
| $%5 eq 0 => Buzz  // 同率優先規則(トランスフォーマ)
. Fizz, Buzz => FizzBuzz  // 規則(トランスフォーマ)
. 1 #stdout => $, \n    // 規則(トランスフォーマ)
```

### 関数の実装

```
// (#,a,b) -> a+b
[add]
. 1 #$[0] => $[1]+$[2]

// (#,n) -> n!
[factorial]
. $ len eq 2 => ($[0], $[1], 1)
. $[1]<=1 #$[0] => $[2]
. 1 => ($[0], $[1]-1, $[2]*$[1])

[send]
a
. $ is int #factorial => (#printResult, $)
. 1 #add => (#, 2, 3)

[printResult]
. 1 #stdout => "(2+3)! = ", $, \n
```

コロニーの参照(`#`は自分自身を表す)をリソースとして渡すことができ、これを利用して関数を実装することができます。
