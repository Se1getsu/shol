# 字句解析

ここでは、解析されるトークンの仕様について説明しています。ただし、無用な説明の複雑化を避けるため、実際には字句解析だけでなく文法レベルで実装を行なっている内容も含まれています。

## 空白文字

空白文字は無視されるため、リテラルなどのトークンの途中を除き、任意の位置に挿入することができます。

```
空白文字 ::= " " | "\t"
```

## 改行

Shol では、改行をトークンとして扱います。

```
改行 ::= "\n" | "\r\n" | "\r" | "\f"
```

## 識別子

```
識別子 ::= (XID_Start | "_") XID_Continue*
```

識別子は、Logos クレートの正規表現 `(\p{XID_Start}|_)\p{XID_Continue}*` で実装しています。これは Rust の識別子の定義に基づいており、日本語の文字なども識別子として使用することができます。

ただし、以下の予約語は識別子として使用することができません。

- `true`
- `false`

識別子は、コロニー名だけでなく、式中の文字列リテラルの代わりとしても使用されます。

## リテラル

### bool 型リテラル

```
bool型リテラル ::= "true"
               | "false"
```

### double 型リテラル

```
小数部 ::= ("0".."9")+ "."
        | ("0".."9")* "." ("0".."9")+

指数部 ::= ("e" | "E") ("+" | "-")? ("0".."9")+

double型リテラル ::= 小数部 指数部?
                 | ("0".."9")+ 指数部?
```

例：`0.1`, `1.0`, `1.`, `.1`, `1e1`, `1.2e+1`, `1e-5`

### int 型リテラル

```
int型リテラル ::= "0"
              | ("1".."9") ("0".."9")*
```

### str 型リテラル

`"` で囲まれた文字列リテラルに対応します。以下は対応しているエスケープシーケンスの一覧です。

- `\0` : ヌル文字
- `\a` : ベル (警告)
- `\b` : バックスペース
- `\t` : タブ
- `\n` : 改行
- `\v` : 垂直タブ
- `\f` : フォームフィード
- `\r` : キャリッジリターン
- `\e` : エスケープ
- `\"` : ダブルクォート
- `\\` : バックスラッシュ
- `\xXX`, `\uXXXX`, `\UXXXXXXXX` : 16進数表記の Unicode 文字 (X: 0-9, A-F, a-f)

### symbol 型リテラル

```
symbol型リテラル ::= "'" 識別子?
```

## キャプチャ

```
キャプチャ ::= "$" 識別子?
```

## 出力先

```
出力先 ::= "#" 識別子?
```

## コメント

コメントはトークン化されず、無視されます。

1 行のコメントでは `//` を、1 行以上に渡るコメントには `/*` ... `*/` によるブロックコメントを使用できます。

ブロックコメントは、以下のようにネストさせることが可能です。

```shol
/*
ここはコメント
/*
ここもコメント
*/
ここもコメント
*/
```

## 演算子・マクロ

`:int`, `.int`, `.abs` などの演算子や、`@debug` のようなマクロは、すべて 1 つのトークンとして解析されます。

また、`:int` と `:i` のような省略形のある演算子は、どちらも同じトークンを生成します。
