# リソース探索

規則は、各条件式にマッチするリソースを見つけるために、リソースキューを探索します。

## 計算量

リソースキューに含まれるリソースの数を `N`、条件式の数を `M` とすると、リソース探索の計算量は以下の通りです。

- 最悪計算量: `O(N * M)`
- 平均計算量: `O(N * M)`
- 最良計算量: `O(N)`

## 探索アルゴリズム

### 例 1：単一条件式

リソースキューを先頭から探索し、各リソースを以下の手順で判定します。

1. リソースの型が求めているものではないなら、スキップ
2. リソースが条件式を満足しないなら、スキップ
3. そうでなければ、出力式に変換

例えば、以下の規則は、

```
. $%2=0 # $/2, $*2
```

以下のようにリソース探索を行います。

```
[3, 4, "foo", 6, "bar"]
 ^
 3%2=0 は偽なのでスキップ

[3, 4, "foo", 6, "bar"]
    ^
  4%2=0 は真なので出力式に変換

[3, 2, 8, "foo", 6, "bar"]
          ^^^^^
   型が合わないのでスキップ

[3, 2, 8, "foo", 6, "bar"]
                 ^
     6%2=0 は真なので出力式に変換

[3, 2, 8, "foo", 3, 12, "bar"]
                        ^^^^^
          型が合わないのでスキップ

[3, 2, 8, "foo", 3, 12, "bar"]
```

### 例 2：複数条件式

複数の条件式がある場合は、少し手順が複雑になります。

1. 既に他の条件式でマッチ済みのリソースは、スキップ
1. リソースの型が求めているものではないなら、スキップ
2. リソースが条件式を満足しないなら、スキップ
3. そうでなければ、"マッチ済みの印" をつけて、次の条件式に進む

例えば、以下の規則は、

```
. $a:str, $b:int # $b*10, 0
```

以下のようにリソース探索を行います。`-` は "マッチ済みの印" を表します。

```
   [3, 'a, "foo", "bar", 4, "hoge"]
$a: ^スキップ
$b:

   [3, 'a, "foo", "bar", 4, "hoge"]
$a:    ^^スキップ
$b:

   [3, 'a, "foo", "bar", 4, "hoge"]
$a:        ^^^^^マッチ
$b:

   [3, 'a, "foo", "bar", 4, "hoge"]
$a:        -----
$b: ^マッチ

   [3, 'a, "foo", "bar", 4, "hoge"]
$a:        -----  ^^^^^マッチ
$b: -
注: 探索再開時には、最後にその条件式でマッチしたリソースの
    次のリソースから探索を再開します。

   [3, 'a, "foo", "bar", 4, "hoge"]
$a:        -----  ^^^^^
$b: -  ^^スキップ

   [3, 'a, "foo", "bar", 4, "hoge"]
$a:        -----  ^^^^^
$b: -                    ^マッチ

   [3, 'a, "foo", "bar", 4, "hoge"]
$a:        -----  -----     ^^^^^^マッチ
$b: -                    -
注: $bの条件式の探索が終端に達するので、これで終了です。

   [3, 'a, "foo", "bar", 4, "hoge"]
$a:        -----  -----     ------
$b: -                    -
   マッチしたリソースを出力式に変換

    ['a, 30, 0, 40, 0, "hoge"]
注: 1 つ目の条件式がマッチした位置に、出力式が挿入されます。
```









