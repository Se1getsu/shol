use std::io::{ self, Write };
use crate::ast;
use crate::semantics::Type;

// MARK: ヘルパー関数など

impl Type {
    /// 実際の Rust の型名を返す
    fn actual(&self) -> String {
        match self {
            Type::String => "String".to_string(),
            Type::Int => "i32".to_string(),
            Type::Bool => "bool".to_string(),
        }
    }
}

/// 中間コードで使用する識別子を管理する
struct Identf;
impl Identf {
    /// リソースの型の列挙型
    const EN_TYPE: &'static str = "ResourceType";
    /// コロニーの規則を実行するメソッド
    const FN_RULE: &'static str = "rule";
    /// リソースのメンバ変数
    const ME_RESOURCE: &'static str = "resources";

    /// コロニーの構造体
    fn colony(name: &str) -> String {
        format!("Colony_{}", name)
    }
}

// MARK: コード生成 - プログラム, コロニー

pub fn generate<W: Write>(
    f: &mut W,
    ast: &Vec<ast::StatementAST>,
    src_file: &String,
) -> io::Result<()> {
    // ヘッダ
    writeln!(f, "// Generated by Shol compiler.")?;
    writeln!(f, "// DO NOT EDIT MANUALLY.")?;
    writeln!(f, "//")?;
    writeln!(f, "// Original source: {}", src_file)?;
    writeln!(f, "// Shol version: {}", env!("CARGO_PKG_VERSION"))?;
    writeln!(f, "")?;

    // 警告の非表示
    writeln!(f, "#![allow(")?;
    writeln!(f, "  non_snake_case,")?;
    writeln!(f, "  non_camel_case_types,")?;
    writeln!(f, "  dead_code,")?;
    writeln!(f, "  unused_variables,")?;
    writeln!(f, "  unused_imports,")?;
    writeln!(f, "  unused_mut,")?;
    writeln!(f, ")]")?;

    // use 宣言
    writeln!(f, "use std::collections::HashMap;")?;
    writeln!(f, "")?;

    // 型定義
    writeln!(f, "#[derive(Eq,Debug,PartialEq,Clone)]")?;
    writeln!(f, "enum {} {{", Identf::EN_TYPE)?;
    for t in Type::all_types() {
        writeln!(f, "  {:?}({}),", t, t.actual())?;
    }
    writeln!(f, "}}")?;

    // ステートメント
    for stmt in ast {
        writeln!(f, "")?;
        match stmt {
            ast::StatementAST::ColonyDecl { name, rules, .. } =>
                generate_colony_decl(name, rules, f)?,
            ast::StatementAST::ColonyExtension { name, rules, .. } =>
                generate_colony_extension(name, rules, f)?,
        }
    }

    // メイン関数
    writeln!(f, "")?;
    writeln!(f, "fn main() {{")?;
    writeln!(f, "  todo!()")?;
    writeln!(f, "}}")?;

    Ok(())
}

fn generate_colony_decl(
    name: &str,
    _rules: &Vec<ast::RuleSetAST>,
    f: &mut impl Write
) -> io::Result<()> {
    let colony_name = Identf::colony(name);

    writeln!(f, "struct {} {{", colony_name)?;
    writeln!(f, "  {}: HashMap<String, {}>,", Identf::ME_RESOURCE, Identf::EN_TYPE)?;
    writeln!(f, "}}")?;
    writeln!(f, "impl {} {{", colony_name)?;
    writeln!(f, "  fn {}(&mut self) {{", Identf::FN_RULE)?;
    writeln!(f, "    todo!();")?;
    writeln!(f, "  }}")?;
    writeln!(f, "}}")?;

    Ok(())
}

fn generate_colony_extension(
    name: &str,
    _rules: &Vec<ast::RuleSetAST>,
    f: &mut impl Write
) -> io::Result<()> {
    let colony_name = Identf::colony(name);

    writeln!(f, "struct {} {{", colony_name)?;
    writeln!(f, "  {}: HashMap<String, {}>,", Identf::ME_RESOURCE, Identf::EN_TYPE)?;
    writeln!(f, "}}")?;
    writeln!(f, "impl {} {{", colony_name)?;
    writeln!(f, "  fn {}(&mut self) {{", Identf::FN_RULE)?;
    writeln!(f, "    todo!();")?;
    writeln!(f, "  }}")?;
    writeln!(f, "}}")?;

    Ok(())
}
