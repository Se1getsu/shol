use crate::tokens::{Token, LexicalError};
use crate::ast;
use crate::semantics;
grammar;

// MARK: 構文

pub Program: Vec<ast::StatementAST> = {
    "nl"* <stmts:Statement*> => stmts
};

Statement: ast::StatementAST = {
    "*" <name:"identf"> "nl"+ <resources:Resource*> <prules:RuleSet*> => {
        ast::StatementAST::ColonyDecl {
            name,
            resources,
            rules: prules,
        }
    },
    "%" <name:"identf"> "nl"+ <resources:Resource*> <prules:RuleSet*> => {
        ast::StatementAST::ColonyExtension {
            name,
            resources,
            rules: prules,
        }
    }
}

Resource: ast::ExprAST = {
    <Literal> "nl"+,
}

RuleSet: ast::RuleSetAST = {
    <first:FirstRule> <later:ParallelRule*> => {
        let mut rules = vec![first];
        rules.extend(later.into_iter().map(|r| r));
        ast::RuleSetAST { rules }
    }
}

FirstRule: ast::RuleAST = {
    "." <Rule> "nl"+
}

ParallelRule: ast::RuleAST = {
    "|" <Rule> "nl"+
}

Rule: ast::RuleAST = {
    <conds:CommaListing<Condition>> <outs:Outputs> => {
        ast::RuleAST {
            conditions: conds,
            outputs: outs,
            meta: None,
        }
    },
}

Condition: ast::ConditionAST = {
    <Expr> => ast::ConditionAST { expr: *<>, meta: None },
}

Outputs: Vec<ast::OutputAST> = {
    <OutputsEndsWithDest> => <>.0,
    <OutputsEndsWithExpr> => <>.0,
}
OutputsEndsWithDest: (Vec<ast::OutputAST>, Option<String>) = {
    <dest:"#xx"> => (vec![], dest),
    <outs:Outputs> <dest:"#xx"> => (outs, dest),
}
OutputsEndsWithExpr: (Vec<ast::OutputAST>, Option<String>) = {
    <mut vd:OutputsEndsWithDest> <expr:Expr> => {
        vd.0.push(ast::OutputAST {
            expr: *expr,
            destination: vd.1.clone(),
            meta: None,
        });
        vd
    },
    <mut vd:OutputsEndsWithExpr> "," <expr:Expr> => {
        vd.0.push(ast::OutputAST {
            expr: *expr,
            destination: vd.1.clone(),
            meta: None,
        });
        vd
    },
}

// MARK: 式

Expr: Box<ast::ExprAST> = {
    #[precedence(level="1")]
    <Factor>,
    <Factor> ":int" => {
        Box::new(ast::ExprAST::UnaryOp(ast::UnaryOpcode::As(semantics::Type::Int), <>))
    },
    <Factor> ":str" => {
        Box::new(ast::ExprAST::UnaryOp(ast::UnaryOpcode::As(semantics::Type::String), <>))
    },
    <Factor> ":bool" => {
        Box::new(ast::ExprAST::UnaryOp(ast::UnaryOpcode::As(semantics::Type::Bool), <>))
    },

    #[precedence(level="2")] #[assoc(side="left")]
    <lhs:Expr> "*" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Mul, rhs))
    },
    <lhs:Expr> "/" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Div, rhs))
    },
    <lhs:Expr> "%" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Mod, rhs))
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:Expr> "+" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Add, rhs))
    },
    <lhs:Expr> "-" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Sub, rhs))
    },

    #[precedence(level="4")] #[assoc(side="left")]
    <lhs:Expr> "=" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Eq, rhs))
    },
    <lhs:Expr> "!=" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Ne, rhs))
    },
    <lhs:Expr> "<" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Lt, rhs))
    },
    <lhs:Expr> ">" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Gt, rhs))
    },
    <lhs:Expr> "<=" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Le, rhs))
    },
    <lhs:Expr> ">=" <rhs:Expr> => {
        Box::new(ast::ExprAST::BinaryOp(lhs, ast::Opcode::Ge, rhs))
    },
}

Factor: Box<ast::ExprAST> = {
    #[precedence(level="1")]
    "$xx" => Box::new(ast::ExprAST::Capture(<>)),
    "(" <Expr> ")",
    "-" <Factor> => Box::new(ast::ExprAST::UnaryOp(ast::UnaryOpcode::Neg, <>)),

    #[precedence(level="2")]
    <Literal> => Box::new(<>),
}

Literal: ast::ExprAST = {
    <SignedInt> =>
        ast::ExprAST::Number(<>),
    "identf" =>
        ast::ExprAST::Str(<>),
    "str" =>
        ast::ExprAST::Str(<>),
    "true" =>
        ast::ExprAST::Bool(true),
    "false" =>
        ast::ExprAST::Bool(false),
}

SignedInt: i32 = {
    <n:"int"> => n,
    "-" <n:"int"> => -n,
    <"intmin">,
}

// MARK: ヘルパー非終端記号

// カンマ区切りで 1 つ以上列挙する構文
CommaListing<T>: Vec<T> = {
    T => vec![<>],
    <mut v:CommaListing<T>> "," <e:T> => {
        v.push(e);
        v
    }
}

// MARK: トークン (終端記号)

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "identf" => Token::Identifier(<String>),
        "int" => Token::IntegerLiteral(<i32>),
        "intmin" => Token::IntegerMin(<i32>),
        "str" => Token::StringLiteral(<String>),
        "true" => Token::True,
        "false" => Token::False,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "=" => Token::Equal,
        "!=" => Token::NotEqual,
        "<" => Token::LessThan,
        ">" => Token::GreaterThan,
        "<=" => Token::LessEqual,
        ">=" => Token::GreaterEqual,
        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Mod,
        ":int" => Token::AsInt,
        ":str" => Token::AsStr,
        ":bool" => Token::AsBool,
        "." => Token::Dot,
        "|" => Token::Pipe,
        "," => Token::Comma,
        "#xx" => Token::Destination(<Option<String>>),
        "$xx" => Token::Capture(<String>),
        "nl" => Token::NewLine(<String>),
    }
}
